

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SPEAR(DECILE) documentation! &mdash; SPEAR(DECILE) 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> SPEAR(DECILE)
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">SPEAR(DECILE) documentation!</a></li>
<li><a class="reference internal" href="#labeling">Labeling</a><ul>
<li><a class="reference internal" href="#module-spear.labeling.lf.core">LF</a></li>
<li><a class="reference internal" href="#module-spear.labeling.continuous_scoring.core">Continuous scoring</a></li>
<li><a class="reference internal" href="#module-spear.labeling.apply.core">LFApply</a></li>
<li><a class="reference internal" href="#module-spear.labeling.lf_set.core">LFSet</a></li>
<li><a class="reference internal" href="#module-spear.labeling.analysis.core">LFAnalysis</a></li>
<li><a class="reference internal" href="#module-spear.labeling.prelabels.core">Noisy Labels</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cage">CAGE</a></li>
<li><a class="reference internal" href="#joint-learning-jl">Joint Learning(JL)</a></li>
<li><a class="reference internal" href="#cage-jl-utils">CAGE, JL - UTILS</a><ul>
<li><a class="reference internal" href="#module-spear.utils.data_editor">Data loaders</a></li>
<li><a class="reference internal" href="#cage-and-jl-utils">CAGE and JL utils</a></li>
<li><a class="reference internal" href="#module-spear.utils.utils_jl">JL utils</a></li>
<li><a class="reference internal" href="#module-spear.JL.models.models">Feature-based Models</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implyloss">IMPLYLOSS</a><ul>
<li><a class="reference internal" href="#module-spear.Implyloss.my_checkmate">Implyloss Checkmate</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_checkpoints">Implyloss Checkpoints</a></li>
<li><a class="reference internal" href="#implyloss-config">Implyloss Config</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_data_feeders">Implyloss Data Feeders</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_data_feeder_utils">Implyloss Data Feeders Utils</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_gen_cross_entropy_utils">Implyloss Gen Cross Entropy Utils</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_model">Implyloss Model</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_pr_utils">Implyloss PR Utils</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_test">Implyloss Test</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_train">Implyloss Train</a></li>
<li><a class="reference internal" href="#module-spear.Implyloss.my_utils">Implyloss Utils</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bibilography">Bibilography</a></li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">SPEAR(DECILE)</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>SPEAR(DECILE) documentation!</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="spear-decile-documentation">
<h1>SPEAR(DECILE) documentation!<a class="headerlink" href="#spear-decile-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="labeling">
<h1>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h1>
<section id="module-spear.labeling.lf.core">
<span id="lf"></span><h2>LF<a class="headerlink" href="#module-spear.labeling.lf.core" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.labeling.lf.core.LabelingFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.lf.core.</span></code><code class="sig-name descname"><span class="pre">LabelingFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">…</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resources</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">spear.labeling.preprocess.core.BasePreprocessor</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cont_scorer</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#spear.labeling.continuous_scoring.core.BaseContinuousScorer" title="spear.labeling.continuous_scoring.core.BaseContinuousScorer"><span class="pre">spear.labeling.continuous_scoring.core.BaseContinuousScorer</span></a><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/lf/core.html#LabelingFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf.core.LabelingFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for labeling function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name for this LF object</p></li>
<li><p><strong>f</strong> (<em>Callable</em><em>[</em><em>..</em><em>, </em><em>int</em><em>]</em>) – core function which labels the input</p></li>
<li><p><strong>label</strong> (<em>enum</em>) – Which class this LF corresponds to</p></li>
<li><p><strong>resources</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Additional resources for core function. Defaults to None.</p></li>
<li><p><strong>pre</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>BasePreprocessor</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Preprocessors to apply on input before labeling. Defaults to None.</p></li>
<li><p><strong>cont_scorer</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#spear.labeling.continuous_scoring.core.BaseContinuousScorer" title="spear.labeling.continuous_scoring.core.BaseContinuousScorer"><em>BaseContinuousScorer</em></a><em>]</em><em>, </em><em>optional</em>) – Continuous Scorer to calculate the confidence score. Defaults to None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="spear.labeling.lf.core.labeling_function">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.lf.core.</span></code><code class="sig-name descname"><span class="pre">labeling_function</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resources</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">spear.labeling.preprocess.core.BasePreprocessor</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cont_scorer</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#spear.labeling.continuous_scoring.core.BaseContinuousScorer" title="spear.labeling.continuous_scoring.core.BaseContinuousScorer"><span class="pre">spear.labeling.continuous_scoring.core.BaseContinuousScorer</span></a><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/lf/core.html#labeling_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf.core.labeling_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator class for a labeling function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>, </em><em>optional</em>) – Name for this labeling function. Defaults to None.</p></li>
<li><p><strong>label</strong> (<em>Optional</em><em>[</em><em>Enum</em><em>]</em><em>, </em><em>optional</em>) – An enum. Which class this LF corresponds to. Defaults to None.</p></li>
<li><p><strong>resources</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Additional resources for the LF. Defaults to None.</p></li>
<li><p><strong>pre</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>BasePreprocessor</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Preprocessors to apply on input before labeling . Defaults to None.</p></li>
<li><p><strong>cont_scorer</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#spear.labeling.continuous_scoring.core.BaseContinuousScorer" title="spear.labeling.continuous_scoring.core.BaseContinuousScorer"><em>BaseContinuousScorer</em></a><em>]</em><em>, </em><em>optional</em>) – Continuous Scorer to calculate the confidence score. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the decorator is missing parantheses</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spear.labeling.continuous_scoring.core">
<span id="continuous-scoring"></span><h2>Continuous scoring<a class="headerlink" href="#module-spear.labeling.continuous_scoring.core" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.labeling.continuous_scoring.core.BaseContinuousScorer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.continuous_scoring.core.</span></code><code class="sig-name descname"><span class="pre">BaseContinuousScorer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cf</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">…</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resources</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/continuous_scoring/core.html#BaseContinuousScorer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.continuous_scoring.core.BaseContinuousScorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base Class for Continuous Scoring function used by the Labeling Function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the continuous scoring function</p></li>
<li><p><strong>cf</strong> (<em>Callable</em><em>[</em><em>..</em><em>, </em><em>int</em><em>]</em>) – Core function which calculates continuous score</p></li>
<li><p><strong>resources</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Resources for the scorer. Defaults to None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="spear.labeling.continuous_scoring.core.continuous_scorer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.continuous_scoring.core.</span></code><code class="sig-name descname"><span class="pre">continuous_scorer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resources</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/continuous_scoring/core.html#continuous_scorer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.continuous_scoring.core.continuous_scorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator class for continuous scoring.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>, </em><em>optional</em>) – Name for the decorator. Defaults to None.</p></li>
<li><p><strong>resources</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Resources for the scorer. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If decorator is missing parantheses.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spear.labeling.apply.core">
<span id="lfapply"></span><h2>LFApply<a class="headerlink" href="#module-spear.labeling.apply.core" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.labeling.apply.core.ApplierMetadata">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.apply.core.</span></code><code class="sig-name descname"><span class="pre">ApplierMetadata</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faults</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/apply/core.html#ApplierMetadata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.apply.core.ApplierMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Metadata about Applier call.</p>
<dl class="py method">
<dt id="spear.labeling.apply.core.ApplierMetadata.faults">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">faults</span></code><a class="headerlink" href="#spear.labeling.apply.core.ApplierMetadata.faults" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="spear.labeling.apply.core.BaseLFApplier">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.apply.core.</span></code><code class="sig-name descname"><span class="pre">BaseLFApplier</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lf_set</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#spear.labeling.lf_set.core.LFSet" title="spear.labeling.lf_set.core.LFSet"><span class="pre">spear.labeling.lf_set.core.LFSet</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/apply/core.html#BaseLFApplier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.apply.core.BaseLFApplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for LF applier objects.
Base class for LF applier objects, which executes a set of LFs
on a collection of data points. Subclasses should operate on
a single data point collection format (e.g. <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>).
Subclasses must implement the <code class="docutils literal notranslate"><span class="pre">apply</span></code> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lf_set</strong> (<a class="reference internal" href="#spear.labeling.lf_set.core.LFSet" title="spear.labeling.lf_set.core.LFSet"><em>LFSet</em></a>) – Instace of LFset which has information of set of labeling functions(which is applied on data)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If names of LFs are not unique</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.labeling.apply.core.apply_lfs_to_data_point">
<code class="sig-prename descclassname"><span class="pre">spear.labeling.apply.core.</span></code><code class="sig-name descname"><span class="pre">apply_lfs_to_data_point</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfs</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><span class="pre">spear.labeling.lf.core.LabelingFunction</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_caller</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">spear.labeling.apply.core._FunctionCaller</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><a class="reference internal" href="_modules/spear/labeling/apply/core.html#apply_lfs_to_data_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.apply.core.apply_lfs_to_data_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Label a single data point with a set of LFs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>DataPoint</em>) – Data point to label</p></li>
<li><p><strong>index</strong> (<em>int</em>) – Index of the data point</p></li>
<li><p><strong>lfs</strong> (<em>List</em><em>[</em><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><em>LabelingFunction</em></a><em>]</em>) – List of LFs to label <code class="docutils literal notranslate"><span class="pre">x</span></code> with</p></li>
<li><p><strong>f_caller</strong> (<em>_FunctionCaller</em>) – A <code class="docutils literal notranslate"><span class="pre">_FunctionCaller</span></code> to record failed LF executions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of (data point index, LF index, label enum, confidence) tuples</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>RowData</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="spear.labeling.apply.core.LFApplier">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.apply.core.</span></code><code class="sig-name descname"><span class="pre">LFApplier</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lf_set</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#spear.labeling.lf_set.core.LFSet" title="spear.labeling.lf_set.core.LFSet"><span class="pre">spear.labeling.lf_set.core.LFSet</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/apply/core.html#LFApplier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.apply.core.LFApplier" title="Permalink to this definition">¶</a></dt>
<dd><p>LF applier for a list of data points (e.g. <code class="docutils literal notranslate"><span class="pre">SimpleNamespace</span></code>) or a NumPy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lf_set</strong> (<a class="reference internal" href="#spear.labeling.lf_set.core.LFSet" title="spear.labeling.lf_set.core.LFSet"><em>LFSet</em></a>) – Instace of LFset which has information of set of labeling functions(which is applied on data)</p>
</dd>
</dl>
<dl class="py method">
<dt id="spear.labeling.apply.core.LFApplier.apply">
<code class="sig-name descname"><span class="pre">apply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_points</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fault_tolerant</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_meta</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span> </span><a class="reference internal" href="#spear.labeling.apply.core.ApplierMetadata" title="spear.labeling.apply.core.ApplierMetadata"><span class="pre">spear.labeling.apply.core.ApplierMetadata</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><a class="reference internal" href="_modules/spear/labeling/apply/core.html#LFApplier.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.apply.core.LFApplier.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Label list of data points or a NumPy array with LFs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_points</strong> (<em>Union</em><em>[</em><em>DataPoints</em><em>, </em><em>np.ndarray</em><em>]</em>) – List of data points or NumPy array to be labeled by LFs</p></li>
<li><p><strong>progress_bar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display a progress bar?. Defaults to True.</p></li>
<li><p><strong>fault_tolerant</strong> (<em>bool</em><em>, </em><em>optional</em>) – Output <code class="docutils literal notranslate"><span class="pre">-1</span></code> if LF execution fails?. Defaults to False.</p></li>
<li><p><strong>return_meta</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return metadata from apply call?. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>np.ndarray:</dt><dd><p>Matrix of labels emitted by LFs</p>
</dd>
<dt>ApplierMetadata:</dt><dd><p>Metadata, such as fault counts, for the apply call</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Union[np.ndarray, Tuple[np.ndarray, <a class="reference internal" href="#spear.labeling.apply.core.ApplierMetadata" title="spear.labeling.apply.core.ApplierMetadata">ApplierMetadata</a>]]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-spear.labeling.lf_set.core">
<span id="lfset"></span><h2>LFSet<a class="headerlink" href="#module-spear.labeling.lf_set.core" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.labeling.lf_set.core.LFSet">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.lf_set.core.</span></code><code class="sig-name descname"><span class="pre">LFSet</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lfs</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><span class="pre">spear.labeling.lf.core.LabelingFunction</span></a><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/lf_set/core.html#LFSet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf_set.core.LFSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for Set of Labeling Functions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name for this LFset.</p></li>
<li><p><strong>lfs</strong> (<em>List</em><em>[</em><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><em>LabelingFunction</em></a><em>]</em><em>, </em><em>optional</em>) – List of LFs to add to this object. Defaults to [].</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="spear.labeling.lf_set.core.LFSet.get_lfs">
<code class="sig-name descname"><span class="pre">get_lfs</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><span class="pre">spear.labeling.lf.core.LabelingFunction</span></a><span class="p"><span class="pre">]</span></span><a class="reference internal" href="_modules/spear/labeling/lf_set/core.html#LFSet.get_lfs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf_set.core.LFSet.get_lfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns LFs contained in this LFSet object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>LFs in this LFSet</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Set[<a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction">LabelingFunction</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.lf_set.core.LFSet.add_lf">
<code class="sig-name descname"><span class="pre">add_lf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lf</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><span class="pre">spear.labeling.lf.core.LabelingFunction</span></a></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">None</span><a class="reference internal" href="_modules/spear/labeling/lf_set/core.html#LFSet.add_lf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf_set.core.LFSet.add_lf" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds single LF to this LFSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lf</strong> (<a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><em>LabelingFunction</em></a>) – LF to add</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.lf_set.core.LFSet.add_lf_list">
<code class="sig-name descname"><span class="pre">add_lf_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lf_list</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><span class="pre">spear.labeling.lf.core.LabelingFunction</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">None</span><a class="reference internal" href="_modules/spear/labeling/lf_set/core.html#LFSet.add_lf_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf_set.core.LFSet.add_lf_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a list of LFs to this LFSet</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lf_list</strong> (<em>List</em><em>[</em><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><em>LabelingFunction</em></a><em>]</em>) – List of LFs to add to this LFSet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.lf_set.core.LFSet.remove_lf">
<code class="sig-name descname"><span class="pre">remove_lf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lf</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><span class="pre">spear.labeling.lf.core.LabelingFunction</span></a></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">None</span><a class="reference internal" href="_modules/spear/labeling/lf_set/core.html#LFSet.remove_lf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.lf_set.core.LFSet.remove_lf" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a LF from this set</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lf</strong> (<a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><em>LabelingFunction</em></a>) – LF to remove from this set</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Warning</strong> – If LF not already in LFset</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-spear.labeling.analysis.core">
<span id="lfanalysis"></span><h2>LFAnalysis<a class="headerlink" href="#module-spear.labeling.analysis.core" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.labeling.analysis.core.LFAnalysis">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.labeling.analysis.core.</span></code><code class="sig-name descname"><span class="pre">LFAnalysis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rules</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Run analysis on LFs using label matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>np.ndarray</em>) – Label matrix where L_{i,j} is the label given by the jth LF to the ith x instance</p></li>
<li><p><strong>lfs</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><a class="reference internal" href="#spear.labeling.lf.core.LabelingFunction" title="spear.labeling.lf.core.LabelingFunction"><em>LabelingFunction</em></a><em>]</em><em>]</em><em>, </em><em>optional</em>) – Labeling functions used to generate <cite>‘L`</cite>. Defaults to None.</p></li>
<li><p><strong>abstain</strong> (<em>int</em><em>, </em><em>optional</em>) – label associated with abstain. Defaults to -1.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If number of LFs and number of LF matrix columns differ</p>
</dd>
</dl>
<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.label_coverage">
<code class="sig-name descname"><span class="pre">label_coverage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.label_coverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.label_coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the fraction of data points with at least one label.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fraction of data points with labels</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">label_coverage</span><span class="p">()</span>
<span class="go">0.8</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.label_overlap">
<code class="sig-name descname"><span class="pre">label_overlap</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.label_overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.label_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the fraction of data points with at least two (non-abstain) labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fraction of data points with overlapping labels</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">label_overlap</span><span class="p">()</span>
<span class="go">0.6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.label_conflict">
<code class="sig-name descname"><span class="pre">label_conflict</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.label_conflict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.label_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the fraction of data points with conflicting (non-abstain) labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fraction of data points with conflicting labels</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">label_conflict</span><span class="p">()</span>
<span class="go">0.2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.lf_polarities">
<code class="sig-name descname"><span class="pre">lf_polarities</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.lf_polarities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.lf_polarities" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer the polarities of each LF based on evidence in a label matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Unique output labels for each LF</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[List[int]]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">lf_polarities</span><span class="p">()</span>
<span class="go">[[0, 1], [0], [0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.lf_coverages">
<code class="sig-name descname"><span class="pre">lf_coverages</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">numpy.ndarray</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.lf_coverages"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.lf_coverages" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute frac. of examples each LF labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Fraction of labeled examples for each LF</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">lf_coverages</span><span class="p">()</span>
<span class="go">array([0.4, 0.8, 0.4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.lf_overlaps">
<code class="sig-name descname"><span class="pre">lf_overlaps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalize_by_coverage</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">numpy.ndarray</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.lf_overlaps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.lf_overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute frac. of examples each LF labels that are labeled by another LF.
An overlapping example is one that at least one other LF returns a
(non-abstain) label for.
Note that the maximum possible overlap fraction for an LF is the LF’s
coverage, unless <code class="docutils literal notranslate"><span class="pre">normalize_by_coverage=True</span></code>, in which case it is 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>normalize_by_coverage</strong> (<em>bool</em><em>, </em><em>optional</em>) – Normalize by coverage of the LF,
so that it returns the percent of LF labels that have overlaps.
Defaults to False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Fraction of overlapping examples for each LF</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">lf_overlaps</span><span class="p">()</span>
<span class="go">array([0.4, 0.6, 0.4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">lf_overlaps</span><span class="p">(</span><span class="n">normalize_by_coverage</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1.  , 0.75, 1.  ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.lf_conflicts">
<code class="sig-name descname"><span class="pre">lf_conflicts</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalize_by_overlaps</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">numpy.ndarray</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.lf_conflicts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.lf_conflicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute frac. of examples each LF labels and labeled differently by another LF.
A conflicting example is one that at least one other LF returns a
different (non-abstain) label for.
Note that the maximum possible conflict fraction for an LF is the LF’s
overlaps fraction, unless <code class="docutils literal notranslate"><span class="pre">normalize_by_overlaps=True</span></code>, in which case it is 1.
Parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>normalize_by_overlaps</strong> (<em>bool</em><em>, </em><em>optional</em>) – Normalize by overlaps of the LF, so that it returns the percent of LF
overlaps that have conflicts.
Defaults to False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Fraction of conflicting examples for each LF</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">lf_conflicts</span><span class="p">()</span>
<span class="go">array([0.2, 0.2, 0. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LFAnalysis</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">lf_conflicts</span><span class="p">(</span><span class="n">normalize_by_overlaps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([0.5       , 0.33333333, 0.        ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.lf_empirical_accuracies">
<code class="sig-name descname"><span class="pre">lf_empirical_accuracies</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">numpy.ndarray</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.lf_empirical_accuracies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.lf_empirical_accuracies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute empirical accuracy against a set of labels Y for each LF.
Usually, Y represents development set labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>np.ndarray</em>) – [n] np.ndarray of gold labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Empirical accuracies for each LF</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.labeling.analysis.core.LFAnalysis.lf_summary">
<code class="sig-name descname"><span class="pre">lf_summary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">pandas.core.frame.DataFrame</span><a class="reference internal" href="_modules/spear/labeling/analysis/core.html#LFAnalysis.lf_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.labeling.analysis.core.LFAnalysis.lf_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pandas DataFrame with the various per-LF statistics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>np.ndarray</em><em>]</em><em>, </em><em>optional</em>) – [n] np.ndarray of gold labels.
If provided, the empirical accuracy for each LF will be calculated.
Defaults to None.</p></li>
<li><p><strong>plot</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>, </em><em>optional</em>) – If set to true a bar graph is plotted. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Summary statistics for each LF</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-spear.labeling.prelabels.core">
<span id="noisy-labels"></span><h2>Noisy Labels<a class="headerlink" href="#module-spear.labeling.prelabels.core" title="Permalink to this headline">¶</a></h2>
</section>
</section>
<hr class="docutils" />
<section id="cage">
<h1>CAGE<a class="headerlink" href="#cage" title="Permalink to this headline">¶</a></h1>
<p><span id="id1">Chatterjee <em>et al.</em> [<a class="reference internal" href="#id15">CRS20</a>]</span></p>
<span class="target" id="module-spear.Cage.core"></span><dl class="py class">
<dt id="spear.Cage.core.Cage">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.Cage.core.</span></code><code class="sig-name descname"><span class="pre">Cage</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_json</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_lfs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Cage class:</dt><dd><p>Class for Data Programming using CAGE
[Note: from here on, graphical model(gm) and CAGE algorithm terms are used interchangeably]</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_json</strong> – Path to json file consisting of number to string(class name) map</p></li>
<li><p><strong>n_lfs</strong> – number of labelling functions used to generate pickle files</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="spear.Cage.core.Cage.save_params">
<code class="sig-name descname"><span class="pre">save_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage.save_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage.save_params" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>member function to save parameters of Cage</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>save_path</strong> – path to pickle file to save parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.Cage.core.Cage.load_params">
<code class="sig-name descname"><span class="pre">load_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">load_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage.load_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage.load_params" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>member function to load parameters to Cage</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>load_path</strong> – path to pickle file to load parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.Cage.core.Cage.fit_and_predict_proba">
<code class="sig-name descname"><span class="pre">fit_and_predict_proba</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_pkl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['binary']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage.fit_and_predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage.fit_and_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_pkl</strong> – Path to pickle file of input data in standard format</p></li>
<li><p><strong>path_test</strong> – Path to the pickle file containing test data in standard format</p></li>
<li><p><strong>path_log</strong> – Path to log file. No log is produced if path_test is None. Default is None which prints accuracies/f1_scores is printed to terminal</p></li>
<li><p><strong>qt</strong> – Quality guide of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.9</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
<li><p><strong>metric_avg</strong> – List of average metric to be used in calculating f1_score, default is [‘binary’]. Use None for not calculating f1_score</p></li>
<li><p><strong>n_epochs</strong> – Number of epochs, default is 100</p></li>
<li><p><strong>lr</strong> – Learning rate for torch.optim, default is 0.01</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances, num_classes) where i,j-th element is the probability of ith instance being the jth class(the jth value when sorted in ascending order of values in Enum)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.Cage.core.Cage.fit_and_predict">
<code class="sig-name descname"><span class="pre">fit_and_predict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_pkl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['binary']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">need_strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage.fit_and_predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage.fit_and_predict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_pkl</strong> – Path to pickle file of input data in standard format</p></li>
<li><p><strong>path_test</strong> – Path to the pickle file containing test data in standard format</p></li>
<li><p><strong>path_log</strong> – Path to log file. No log is produced if path_test is None. Default is None which prints accuracies/f1_scores is printed to terminal</p></li>
<li><p><strong>qt</strong> – Quality guide of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.9</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
<li><p><strong>metric_avg</strong> – List of average metric to be used in calculating f1_score, default is [‘binary’]</p></li>
<li><p><strong>n_epochs</strong> – Number of epochs, default is 100</p></li>
<li><p><strong>lr</strong> – Learning rate for torch.optim, default is 0.01</p></li>
<li><p><strong>need_strings</strong> – If True, the output will be in the form of strings(class names). Else it is in the form of class values(given to classes in Enum). Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances,) which are aggregated/predicted labels. Elements are numbers/strings depending on need_strings attribute is false/true resp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.Cage.core.Cage.predict_proba">
<code class="sig-name descname"><span class="pre">predict_proba</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Used to predict labels based on a pickle file with path path_test</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_test</strong> – Path to the pickle file containing test data set in standard format</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances, num_classes) where i,j-th element is the probability of ith instance being the jth class(the jth value when sorted in ascending order of values in Enum)
[Note: no aggregration/algorithm-running will be done using the current input]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.Cage.core.Cage.predict">
<code class="sig-name descname"><span class="pre">predict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">need_strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Cage/core.html#Cage.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Cage.core.Cage.predict" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Used to predict labels based on a pickle file with path path_test</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_test</strong> – Path to the pickle file containing test data set in standard format</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
<li><p><strong>need_strings</strong> – If True, the output will be in the form of strings(class names). Else it is in the form of class values(given to classes in Enum). Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances,) which are predicted labels. Elements are numbers/strings depending on need_strings attribute is false/true resp.
[Note: no aggregration/algorithm-running will be done using the current input]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="joint-learning-jl">
<h1>Joint Learning(JL)<a class="headerlink" href="#joint-learning-jl" title="Permalink to this headline">¶</a></h1>
<p><span id="id2">Maheshwari <em>et al.</em> [<a class="reference internal" href="#id16">MCK+20</a>]</span></p>
<blockquote>
<div><p>From here on, Feature model(fm) imply Feature based classification model</p>
</div></blockquote>
<span class="target" id="module-spear.JL.core"></span><dl class="py class">
<dt id="spear.JL.core.JL">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.JL.core.</span></code><code class="sig-name descname"><span class="pre">JL</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_json</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_lfs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_hidden</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nn'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Joint_Learning class:</dt><dd><p>[Note: from here on, feature model(fm) and feature-based classification model are used interchangeably. graphical model(gm) and CAGE algorithm terms are used interchangeably]</p>
<p>Loss function number, Calculated over, Loss function: (useful for loss_func_mask in fit_and_predict_proba and fit_and_predict functions)</p>
<blockquote>
<div><p>1, L, Cross Entropy(prob_from_feature_model, true_labels)</p>
<p>2, U, Entropy(prob_from_feature_model)</p>
<p>3, U, Cross Entropy(prob_from_feature_model, prob_from_graphical_model)</p>
<p>4, L, Negative Log Likelihood</p>
<p>5, U, Negative Log Likelihood(marginalised over true labels)</p>
<p>6, L and U, KL Divergence(prob_feature_model, prob_graphical_model)</p>
<p>7, Quality guide</p>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_json</strong> – Path to json file containing the dictionary of number to string(class name) map</p></li>
<li><p><strong>n_lfs</strong> – number of labelling functions used to generate pickle files</p></li>
<li><p><strong>n_features</strong> – number of features for each instance in the first array of pickle file aka feature matrix</p></li>
<li><p><strong>n_hidden</strong> – Number of hidden layer nodes if feature model is ‘nn’, type is integer, default is 512</p></li>
<li><p><strong>feature_model</strong> – The model intended to be used for features, allowed values are ‘lr’(Logistic Regression) or ‘nn’(Neural network with 2 hidden layer) string, default is ‘nn’</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="spear.JL.core.JL.save_params">
<code class="sig-name descname"><span class="pre">save_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.save_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.save_params" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>member function to save parameters of JL</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>save_path</strong> – path to pickle file to save parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.load_params">
<code class="sig-name descname"><span class="pre">load_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">load_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.load_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.load_params" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>member function to load parameters to JL</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>load_path</strong> – path to pickle file to load parameters</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.fit_and_predict_proba">
<code class="sig-name descname"><span class="pre">fit_and_predict_proba</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_func_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_fm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_gm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_accuracy_score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_gm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_qt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'macro'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.fit_and_predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.fit_and_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_L</strong> – Path to pickle file of labelled instances</p></li>
<li><p><strong>path_U</strong> – Path to pickle file of unlabelled instances</p></li>
<li><p><strong>path_V</strong> – Path to pickle file of validation instances</p></li>
<li><p><strong>path_T</strong> – Path to pickle file of test instances</p></li>
<li><p><strong>loss_func_mask</strong> – list/numpy array of size 7 or (7,) where loss_func_mask[i] should be 1 if Loss function (i+1) should be included, 0 else. Checkout Eq(3) in <span id="id3">[<a class="reference internal" href="#id16">MCK+20</a>]</span></p></li>
<li><p><strong>batch_size</strong> – Batch size, type should be integer</p></li>
<li><p><strong>lr_fm</strong> – Learning rate for feature model, type is integer or float</p></li>
<li><p><strong>lr_gm</strong> – Learning rate for graphical model(cage algorithm), type is integer or float</p></li>
<li><p><strong>use_accuracy_score</strong> – The score to use for termination condition on validation set. True for accuracy_score, False for f1_score</p></li>
<li><p><strong>path_log</strong> – Path to log file to append log. Default is None which prints accuracies/f1_scores is printed to terminal</p></li>
<li><p><strong>return_gm</strong> – Return the predictions of graphical model? the allowed values are True, False. Default value is False</p></li>
<li><p><strong>n_epochs</strong> – Number of epochs in each run, type is integer, default is 100</p></li>
<li><p><strong>start_len</strong> – A parameter used in validation refers to the least epoch after which validation checks need to be performed, type is integer, default is 7</p></li>
<li><p><strong>stop_len</strong> – A parameter used in validation refers to the least number of continuous epochs of non incresing validation accuracy after which the training should be stopped, type is integer, default is 10</p></li>
<li><p><strong>is_qt</strong> – True if quality guide is available(and will be provided in ‘qt’ argument). False if quality guide is intended to be found from validation instances. Default is True</p></li>
<li><p><strong>is_qc</strong> – True if quality index is available(and will be provided in ‘qc’ argument). False if quality index is intended to be found from validation instances. Default is True</p></li>
<li><p><strong>qt</strong> – Quality guide of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.9</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
<li><p><strong>metric_avg</strong> – Average metric to be used in calculating f1_score/precision/recall, default is ‘macro’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If return_gm is True; the return value is two predicted labels of numpy array of shape (num_instances, num_classes), first one is through feature model, other one through graphical model.
Else; the return value is predicted labels of numpy array of shape (num_instances, num_classes) through feature model. For a given model i,j-th element is the probability of ith instance being the
jth class(the jth value when sorted in ascending order of values in Enum) using that model. It is suggested to use the probailities of feature model</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.fit_and_predict">
<code class="sig-name descname"><span class="pre">fit_and_predict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_func_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_fm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_gm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_accuracy_score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_gm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_qt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'macro'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">need_strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.fit_and_predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.fit_and_predict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_L</strong> – Path to pickle file of labelled instances</p></li>
<li><p><strong>path_U</strong> – Path to pickle file of unlabelled instances</p></li>
<li><p><strong>path_V</strong> – Path to pickle file of validation instances</p></li>
<li><p><strong>path_T</strong> – Path to pickle file of test instances</p></li>
<li><p><strong>loss_func_mask</strong> – list/numpy array of size 7 or (7,) where loss_func_mask[i] should be 1 if Loss function (i+1) should be included, 0 else. Checkout Eq(3) in <span id="id4">[<a class="reference internal" href="#id16">MCK+20</a>]</span></p></li>
<li><p><strong>batch_size</strong> – Batch size, type should be integer</p></li>
<li><p><strong>lr_fm</strong> – Learning rate for feature model, type is integer or float</p></li>
<li><p><strong>lr_gm</strong> – Learning rate for graphical model(cage algorithm), type is integer or float</p></li>
<li><p><strong>use_accuracy_score</strong> – The score to use for termination condition on validation set. True for accuracy_score, False for f1_score</p></li>
<li><p><strong>path_log</strong> – Path to log file to append log. Default is None which prints accuracies/f1_scores is printed to terminal</p></li>
<li><p><strong>return_gm</strong> – Return the predictions of graphical model? the allowed values are True, False. Default value is False</p></li>
<li><p><strong>n_epochs</strong> – Number of epochs in each run, type is integer, default is 100</p></li>
<li><p><strong>start_len</strong> – A parameter used in validation, type is integer, default is 7</p></li>
<li><p><strong>stop_len</strong> – A parameter used in validation, type is integer, default is 10</p></li>
<li><p><strong>is_qt</strong> – True if quality guide is available(and will be provided in ‘qt’ argument). False if quality guide is intended to be found from validation instances. Default is True</p></li>
<li><p><strong>is_qc</strong> – True if quality index is available(and will be provided in ‘qc’ argument). False if quality index is intended to be found from validation instances. Default is True</p></li>
<li><p><strong>qt</strong> – Quality guide of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.9</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
<li><p><strong>metric_avg</strong> – Average metric to be used in calculating f1_score/precision/recall, default is ‘macro’</p></li>
<li><p><strong>need_strings</strong> – If True, the output will be in the form of strings(class names). Else it is in the form of class values(given to classes in Enum). Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If return_gm is True; the return value is two predicted labels of numpy array of shape (num_instances, ), first one is through feature model, other one through graphical model.
Else; the return value is predicted labels of numpy array of shape (num_instances,) through feature model. It is suggested to use the probailities of feature model</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.predict_gm_proba">
<code class="sig-name descname"><span class="pre">predict_gm_proba</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.predict_gm_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.predict_gm_proba" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Used to find the predicted labels based on the trained parameters of graphical model(CAGE)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_test</strong> – Path to the pickle file containing test data set</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances, num_classes) where i,j-th element is the probability of ith instance being the jth class(the jth value when sorted in ascending order of values in Enum)
[Note: no aggregration/algorithm-running will be done using the current input]. It is suggested to use the probailities of feature model</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.predict_fm_proba">
<code class="sig-name descname"><span class="pre">predict_fm_proba</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.predict_fm_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.predict_fm_proba" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Used to find the predicted labels based on the trained parameters of feature model</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path_test</strong> – Path to the pickle file containing test data set</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances, num_classes) where i,j-th element is the probability of ith instance being the jth class(the jth value when sorted in ascending order of values in Enum)
[Note: no aggregration/algorithm-running will be done using the current input]. It is suggested to use the probailities of feature model</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.predict_gm">
<code class="sig-name descname"><span class="pre">predict_gm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">need_strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.predict_gm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.predict_gm" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Used to find the predicted labels based on the trained parameters of graphical model(CAGE)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_test</strong> – Path to the pickle file containing test data set</p></li>
<li><p><strong>qc</strong> – Quality index of shape (n_lfs,) of type numpy.ndarray OR a float. Values must be between 0 and 1. Default is 0.85</p></li>
<li><p><strong>need_strings</strong> – If True, the output will be in the form of strings(class names). Else it is in the form of class values(given to classes in Enum). Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances,) which are predicted labels. Elements are numbers/strings depending on need_strings attribute is false/true resp.
[Note: no aggregration/algorithm-running will be done using the current input]. It is suggested to use the probailities of feature model</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="spear.JL.core.JL.predict_fm">
<code class="sig-name descname"><span class="pre">predict_fm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">need_strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/core.html#JL.predict_fm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.core.JL.predict_fm" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Used to find the predicted labels based on the trained parameters of feature model</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_test</strong> – Path to the pickle file containing test data set</p></li>
<li><p><strong>need_strings</strong> – If True, the output will be in the form of strings(class names). Else it is in the form of class values(given to classes in Enum). Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances,) which are predicted labels. Elements are numbers/strings depending on need_strings attribute is false/true resp.
[Note: no aggregration/algorithm-running will be done using the current input]. It is suggested to use the probailities of feature model</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="cage-jl-utils">
<h1>CAGE, JL - UTILS<a class="headerlink" href="#cage-jl-utils" title="Permalink to this headline">¶</a></h1>
<section id="module-spear.utils.data_editor">
<span id="data-loaders"></span><h2>Data loaders<a class="headerlink" href="#module-spear.utils.data_editor" title="Permalink to this headline">¶</a></h2>
<p>The common utils to CAGE and JL algorithms are in this file. Don’t change the name or location of this file.</p>
<dl class="py function">
<dt id="spear.utils.data_editor.is_dict_trivial">
<code class="sig-prename descclassname"><span class="pre">spear.utils.data_editor.</span></code><code class="sig-name descname"><span class="pre">is_dict_trivial</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/data_editor.html#is_dict_trivial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.data_editor.is_dict_trivial" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)checks if the dictionary have key and value equal values for all keys except if its null</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dict</strong> – the dictionary</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if all keys(which are not None) are equal to respective values. False otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.data_editor.get_data">
<code class="sig-prename descclassname"><span class="pre">spear.utils.data_editor.</span></code><code class="sig-name descname"><span class="pre">get_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_shapes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/data_editor.html#get_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.data_editor.get_data" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl>
<dt>Standard format in pickle file contains the NUMPY ndarrays x, l, m, L, d, r, s, n, k and an int n_classes</dt><dd><p>x: (num_instances, num_features), x[i][j] is jth feature of ith instance. Note that the dimension fo this array can vary depending on the dimension of input</p>
<p>l: (num_instances, num_lfs), l[i][j] is the prediction of jth LF(co-domain: the values used in Enum) on ith instance. l[i][j] = None imply Abstain</p>
<p>m: (num_instances, num_lfs), m[i][j] is 1 if jth LF didn’t Abstain on ith instance. Else it’s 0</p>
<p>L: (num_instances, 1), L[i] is true label(co-domain: the values used in Enum) of ith instance, if available. Else L[i] is None</p>
<p>d: (num_instances, 1), d[i] is 1 if ith instance is labelled. Else it is 0</p>
<p>r: (num_instances, num_lfs), r[i][j] is 1 if ith instance is an exemplar for jth rule. Else it’s 0</p>
<p>s: (num_instances, num_lfs), s[i][j] is the continuous score of ith instance given by jth continuous LF. If jth LF is not continuous, then s[i][j] is None</p>
<p>n: (num_lfs,), n[i] is 1 if ith LF has continuous counter part, else n[i] is 0</p>
<p>k: (num_lfs,), k[i] is the class of ith LF, co-domain: the values used in Enum</p>
<p>n_classes: total number of classes</p>
<p>In case the numpy array is not available, it is stored as np.zeros(0)</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – path to pickle file with data in the format above</p></li>
<li><p><strong>check_shapes</strong> – if true, checks whether the shapes of numpy arrays in pickle file are consistent as per the format mentioned above. Else it doesn’t check. Default is True.</p></li>
<li><p><strong>class_map</strong> – dictionary of class numbers(sorted, mapped to [0,n_classes-1]) are per the Enum defined in labeling part. l,L are modified(needed inside algorithms) before returning, using class_map. Default is None which doesn’t do any mapping</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list containing all the numpy arrays mentioned above. The arrays l, L are modified using the class_map</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.data_editor.get_classes">
<code class="sig-prename descclassname"><span class="pre">spear.utils.data_editor.</span></code><code class="sig-name descname"><span class="pre">get_classes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/data_editor.html#get_classes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.data_editor.get_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The json file should contain a dictionary of number to string(class name) map as defined in Enum</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> – path to json file with contents mentioned above</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary (number to string(class name) map)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.data_editor.get_predictions">
<code class="sig-prename descclassname"><span class="pre">spear.utils.data_editor.</span></code><code class="sig-name descname"><span class="pre">get_predictions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proba</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">need_strings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/data_editor.html#get_predictions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.data_editor.get_predictions" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)This function takes probaility of instances being a class and gives what class each instance belongs to, using the maximum of probabilities</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>proba</strong> – probability numpy.ndarray of shape (num_instances, num_classes)</p></li>
<li><p><strong>class_map</strong> – dictionary mapping the class numbers(as per Enum class defined) to numbers in range [0, num_classes-1]</p></li>
<li><p><strong>class_dict</strong> – dictionary consisting of number to string(class name) mapping as per the Enum class defined</p></li>
<li><p><strong>need_trings</strong> – If True, the output conatians strings(of class names), else it consists of numbers(class numbers as used in Enum definition)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_instances,), where elements are class_names/class_numbers depending on need_strings is True/False, where the elements
represent the class of each instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.data_editor.get_enum">
<code class="sig-prename descclassname"><span class="pre">spear.utils.data_editor.</span></code><code class="sig-name descname"><span class="pre">get_enum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">np_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/data_editor.html#get_enum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.data_editor.get_enum" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This function is used to convert a numpy array of numbers to a numpy array of enums based on the Enum class provided ‘enm’</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>np_array</strong> – a numpy.ndarray of any shape consisting of numbers</p></li>
<li><p><strong>enm</strong> – An class derived from ‘Enum’ class, which must contain map from every number in np_array to an enum</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape shape as np_array but now contains enums(as per the mapping in ‘enm’) instead of numbers</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="cage-and-jl-utils">
<h2>CAGE and JL utils<a class="headerlink" href="#cage-and-jl-utils" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>From here on, Graphical model(gm) imply CAGE algorithm and Feature model(fm) imply Feature based classification model</p>
</div></blockquote>
<span class="target" id="module-spear.utils.utils_cage"></span><p>The common utils to CAGE and JL algorithms are in this file. Don’t change the name or location of this file.</p>
<dl class="py function">
<dt id="spear.utils.utils_cage.phi">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">phi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#phi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.phi" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: A helper function</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>l</strong> – [n_lfs]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tensor of shape [n_classes, n_lfs], element wise product of input tensors(each row of theta dot product with l)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.calculate_normalizer">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">calculate_normalizer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#calculate_normalizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.calculate_normalizer" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Used to find Z(the normaliser) in CAGE. Eq(4) in <span id="id5">[<a class="reference internal" href="#id15">CRS20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>k</strong> – [n_lfs], labels corresponding to LFs</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real value, representing the normaliser</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.probability_l_y">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">probability_l_y</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#probability_l_y"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.probability_l_y" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Used to find probability involving the term psi_theta(in Eq(1) in <span id="id6">[<a class="reference internal" href="#id15">CRS20</a>]</span>), the potential function for all LFs</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>m</strong> – [n_instances, n_lfs], m[i][j] is 1 if jth LF is triggered on ith instance, else it is 0</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tensor of shape [n_instances, n_classes], the psi_theta value for each instance, for each class(true label y)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.probability_s_given_y_l">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">probability_s_given_y_l</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#probability_s_given_y_l"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.probability_s_given_y_l" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Used to find probability involving the term psi_pi(in Eq(1) in <span id="id7">[<a class="reference internal" href="#id15">CRS20</a>]</span>), the potential function for all continuous LFs</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pi</strong> – [n_lfs], the parameters for the class y</p></li>
<li><p><strong>s</strong> – [n_instances, n_lfs], s[i][j] is the continuous score of ith instance given by jth continuous LF</p></li>
<li><p><strong>y</strong> – a value in [0, n_classes-1], representing true label, for which psi_pi is calculated</p></li>
<li><p><strong>m</strong> – [n_instances, n_lfs], m[i][j] is 1 if jth LF is triggered on ith instance, else it is 0</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>continuous_mask</strong> – [n_lfs], continuous_mask[i] is 1 if ith LF has continuous counter part, else it is 0</p></li>
<li><p><strong>qc</strong> – a float value OR [n_lfs], qc[i] quality index for ith LF. Value(s) must be between 0 and 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tensor of shape [n_instances], the psi_pi value for each instance, for the given label(true label y)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.probability">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">probability</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.probability" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Used to find probability of given instances for all possible true labels(y’s). Eq(1) in <span id="id8">[<a class="reference internal" href="#id15">CRS20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>pi</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>m</strong> – [n_instances, n_lfs], m[i][j] is 1 if jth LF is triggered on ith instance, else it is 0</p></li>
<li><p><strong>s</strong> – [n_instances, n_lfs], s[i][j] is the continuous score of ith instance given by jth continuous LF</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
<li><p><strong>continuous_mask</strong> – [n_lfs], continuous_mask[i] is 1 if ith LF has continuous counter part, else it is 0</p></li>
<li><p><strong>qc</strong> – a float value OR [n_lfs], qc[i] quality index for ith LF. Value(s) must be between 0 and 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tensor of shape [n_instances, n_classes], the probability for an instance being a particular class</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.log_likelihood_loss">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">log_likelihood_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#log_likelihood_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.log_likelihood_loss" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Negative of log likelihood loss. Negative of Eq(6) in <span id="id9">[<a class="reference internal" href="#id15">CRS20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>pi</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>m</strong> – [n_instances, n_lfs], m[i][j] is 1 if jth LF is triggered on ith instance, else it is 0</p></li>
<li><p><strong>s</strong> – [n_instances, n_lfs], s[i][j] is the continuous score of ith instance given by jth continuous LF</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
<li><p><strong>continuous_mask</strong> – [n_lfs], continuous_mask[i] is 1 if ith LF has continuous counter part, else it is 0</p></li>
<li><p><strong>qc</strong> – a float value OR [n_lfs], qc[i] quality index for ith LF. Value(s) must be between 0 and 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real value, summation over (the log of probability for an instance, marginalised over y(true labels))</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.precision_loss">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">precision_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#precision_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.precision_loss" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Negative of the regularizer term in Eq(9) in <span id="id10">[<a class="reference internal" href="#id15">CRS20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
<li><p><strong>a</strong> – [n_lfs], a[i] is the quality guide for ith LF. Value(s) must be between 0 and 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real value, negative of regularizer term</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_cage.predict_gm_labels">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_cage.</span></code><code class="sig-name descname"><span class="pre">predict_gm_labels</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_cage.html#predict_gm_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_cage.predict_gm_labels" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Graphical model utils: Used to predict the labels after the training is done</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>pi</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>m</strong> – [n_instances, n_lfs], m[i][j] is 1 if jth LF is triggered on ith instance, else it is 0</p></li>
<li><p><strong>s</strong> – [n_instances, n_lfs], s[i][j] is the continuous score of ith instance given by jth continuous LF</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
<li><p><strong>continuous_mask</strong> – [n_lfs], continuous_mask[i] is 1 if ith LF has continuous counter part, else it is 0</p></li>
<li><p><strong>qc</strong> – a float value OR [n_lfs], qc[i] quality index for ith LF. Value(s) must be between 0 and 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (n_instances,), the predicted class for an instance</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spear.utils.utils_jl">
<span id="jl-utils"></span><h2>JL utils<a class="headerlink" href="#module-spear.utils.utils_jl" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="spear.utils.utils_jl.log_likelihood_loss_supervised">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_jl.</span></code><code class="sig-name descname"><span class="pre">log_likelihood_loss_supervised</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_jl.html#log_likelihood_loss_supervised"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_jl.log_likelihood_loss_supervised" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE IN SPEAR LIBRARY)Joint Learning utils: Negative log likelihood loss, used in loss 4 in <span id="id11">[<a class="reference internal" href="#id16">MCK+20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>pi</strong> – [n_classes, n_lfs], the parameters</p></li>
<li><p><strong>m</strong> – [n_instances, n_lfs], m[i][j] is 1 if jth LF is triggered on ith instance, else it is 0</p></li>
<li><p><strong>s</strong> – [n_instances, n_lfs], s[i][j] is the continuous score of ith instance given by jth continuous LF</p></li>
<li><p><strong>k</strong> – [n_lfs], k[i] is the class of ith LF, range: 0 to num_classes-1</p></li>
<li><p><strong>n_classes</strong> – num of classes/labels</p></li>
<li><p><strong>continuous_mask</strong> – [n_lfs], continuous_mask[i] is 1 if ith LF has continuous counter part, else it is 0</p></li>
<li><p><strong>qc</strong> – a float value OR [n_lfs], qc[i] quality index for ith LF</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real value, summation over (the log of probability for an instance)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_jl.entropy">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_jl.</span></code><code class="sig-name descname"><span class="pre">entropy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probabilities</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_jl.html#entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_jl.entropy" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE IN SPEAR LIBRARY)Joint Learning utils: Entropy, Used in loss 2 in <span id="id12">[<a class="reference internal" href="#id16">MCK+20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>probabilities</strong> – [num_unsup_instances, num_classes], probabilities[i][j] is probability of ith instance being jth class</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real value, the entropy value of given probability</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_jl.kl_divergence">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_jl.</span></code><code class="sig-name descname"><span class="pre">kl_divergence</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probs_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs_q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_jl.html#kl_divergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_jl.kl_divergence" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE IN SPEAR LIBRARY)Joint Learning utils: KL divergence of two probabilities, used in loss 6 in <span id="id13">[<a class="reference internal" href="#id16">MCK+20</a>]</span></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probs_p</strong> – [num_instances, num_classes]</p></li>
<li><p><strong>probs_q</strong> – [num_instances, num_classes]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a real value, the KL divergence of given probabilities</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_jl.find_indices">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_jl.</span></code><code class="sig-name descname"><span class="pre">find_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_sub</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_jl.html#find_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_jl.find_indices" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE IN SPEAR LIBRARY)A helper function for subset selection</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – the complete data, torch tensor of shape [num_instances, num_classes]</p></li>
<li><p><strong>data_sub</strong> – the subset of ‘data’ whose indices are to be found. Should be of same shape as ‘data’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of indices, to be found from the result of apricot library</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="spear.utils.utils_jl.get_similarity_kernel">
<code class="sig-prename descclassname"><span class="pre">spear.utils.utils_jl.</span></code><code class="sig-name descname"><span class="pre">get_similarity_kernel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/utils/utils_jl.html#get_similarity_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.utils.utils_jl.get_similarity_kernel" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE IN SPEAR LIBRARY)A helper function for subset selection</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>preds</strong> – numpy.ndarray of shape (num_samples,)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>numpy.ndarray of shape (num_sample, num_samples)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spear.JL.models.models">
<span id="feature-based-models"></span><h2>Feature-based Models<a class="headerlink" href="#module-spear.JL.models.models" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.JL.models.models.LogisticRegression">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.JL.models.models.</span></code><code class="sig-name descname"><span class="pre">LogisticRegression</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/models/models.html#LogisticRegression"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.models.models.LogisticRegression" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Class for Logistic Regression, used in Joint learning class/Algorithm</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_size</strong> – number of features</p></li>
<li><p><strong>output_size</strong> – number of classes</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="spear.JL.models.models.LogisticRegression.forward">
<code class="sig-name descname"><span class="pre">forward</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/models/models.html#LogisticRegression.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.models.models.LogisticRegression.forward" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="spear.JL.models.models.DeepNet">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.JL.models.models.</span></code><code class="sig-name descname"><span class="pre">DeepNet</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/models/models.html#DeepNet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.models.models.DeepNet" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>(NOT AVAILABLE AS PART OF SPEAR LIBRARY)Class for Deep neural network, used in Joint learning class/Algorithm</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_size</strong> – number of features</p></li>
<li><p><strong>hidden_size</strong> – number of nodes in each of the two hidden layers</p></li>
<li><p><strong>output_size</strong> – number of classes</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="spear.JL.models.models.DeepNet.forward">
<code class="sig-name descname"><span class="pre">forward</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/JL/models/models.html#DeepNet.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.JL.models.models.DeepNet.forward" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="implyloss">
<h1>IMPLYLOSS<a class="headerlink" href="#implyloss" title="Permalink to this headline">¶</a></h1>
<section id="module-spear.Implyloss.my_checkmate">
<span id="implyloss-checkmate"></span><h2>Implyloss Checkmate<a class="headerlink" href="#module-spear.Implyloss.my_checkmate" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.Implyloss.my_checkmate.BestCheckpointSaver">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_checkmate.</span></code><code class="sig-name descname"><span class="pre">BestCheckpointSaver</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_to_keep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkmate.html#BestCheckpointSaver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkmate.BestCheckpointSaver" title="Permalink to this definition">¶</a></dt>
<dd><p>Maintains a directory containing only the best n checkpoints</p>
<p>Inside the directory is a best_checkpoints JSON file containing a dictionary
mapping of the best checkpoint filepaths to the values by which the checkpoints
are compared.  Only the best n checkpoints are contained in the directory and JSON file.</p>
<p>This is a light-weight wrapper class only intended to work in simple,
non-distributed settings.  It is not intended to work with the tf.Estimator
framework.</p>
<dl class="py method">
<dt id="spear.Implyloss.my_checkmate.BestCheckpointSaver.handle">
<code class="sig-name descname"><span class="pre">handle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_step_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkmate.html#BestCheckpointSaver.handle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkmate.BestCheckpointSaver.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Updates the set of best checkpoints based on the given result.</p>
<p>Input:
value: The value by which to rank the checkpoint.
sess: A tf.Session to use to save the checkpoint
global_step_tensor: A <cite>tf.Tensor</cite> represent the global step</p>
<p>Output:
True or False</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_checkmate.get_best_checkpoint">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_checkmate.</span></code><code class="sig-name descname"><span class="pre">get_best_checkpoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">best_checkpoint_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">select_maximum_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkmate.html#get_best_checkpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkmate.get_best_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Reads the best_checkpoints file in the best_checkpoint_dir directory.
Returns the filepath in the best_checkpoints file associated with
the highest value if select_maximum_value is True, or the filepath
associated with the lowest value if select_maximum_value is False.</p>
<p>Input:
best_checkpoint_dir: Directory containing best_checkpoints JSON file
select_maximum_value: If True, select the filepath associated
with the highest value.  Otherwise, select the filepath associated
with the lowest value.</p>
<p>Output:
The full path to the best checkpoint file</p>
</dd></dl>

</section>
<section id="module-spear.Implyloss.my_checkpoints">
<span id="implyloss-checkpoints"></span><h2>Implyloss Checkpoints<a class="headerlink" href="#module-spear.Implyloss.my_checkpoints" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="spear.Implyloss.my_checkpoints.test_mru_checkpoints">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_checkpoints.</span></code><code class="sig-name descname"><span class="pre">test_mru_checkpoints</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_to_keep</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkpoints.html#test_mru_checkpoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkpoints.test_mru_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Runs different sessions while changing the checkpoint number that is currently being worked with and tests the same</p>
<p>Input:
num_to_keep(int) - a limit on the size of the global step for checkpoint traversal</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_checkpoints.test_checkpoint">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_checkpoints.</span></code><code class="sig-name descname"><span class="pre">test_checkpoint</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkpoints.html#test_checkpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkpoints.test_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
tests whether the checkpoints stored are as expected</p>
<p>Input:</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_checkpoints.test_best_ckpt">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_checkpoints.</span></code><code class="sig-name descname"><span class="pre">test_best_ckpt</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkpoints.html#test_best_ckpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkpoints.test_best_ckpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
test for the best checkpoint so far</p>
<p>Input:</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_checkpoints.test_checkmate">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_checkpoints.</span></code><code class="sig-name descname"><span class="pre">test_checkmate</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_checkpoints.html#test_checkmate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_checkpoints.test_checkmate" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
test whether the checkmate model is working fine</p>
<p>Input:</p>
<p>Output:</p>
</dd></dl>

</section>
<section id="implyloss-config">
<h2>Implyloss Config<a class="headerlink" href="#implyloss-config" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-spear.Implyloss.my_data_feeders">
<span id="implyloss-data-feeders"></span><h2>Implyloss Data Feeders<a class="headerlink" href="#module-spear.Implyloss.my_data_feeders" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-spear.Implyloss.my_data_feeder_utils">
<span id="implyloss-data-feeders-utils"></span><h2>Implyloss Data Feeders Utils<a class="headerlink" href="#module-spear.Implyloss.my_data_feeder_utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.load_data">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">load_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_load</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#load_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
load the data from the given file</p>
<p>Input:
fname - filename
num_load (default - None)</p>
<p>Output:
the structured F_d_U_Data</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.get_rule_classes">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">get_rule_classes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#get_rule_classes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.get_rule_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
get the different rule_classes</p>
<p>Input:
l ([batch_size, num_rules])
num_classes (int) - the number of available classes</p>
<p>Output:
rule_classes ([num_rules,1]) - the list of valid classes labelled by rules (say class 2 by r0, class 1 by r1, class 4 by r2 =&gt; [2,1,4])</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.extract_rules_satisfying_min_coverage">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">extract_rules_satisfying_min_coverage</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_coverage</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#extract_rules_satisfying_min_coverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.extract_rules_satisfying_min_coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
extract the rules that satisfy the specified minimum coverage</p>
<p>Input:
m ([batch_size, num_rules]) - mij specifies whether ith example is associated with the jth rule
min_coverage</p>
<p>Output:
satisfying_rules - list of satisfying rules
not_satisfying_rules - list of not satisfying rules
rule_map_new_to_old
rule_map_old_to_new</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.remap_2d_array">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">remap_2d_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_old_to_new</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#remap_2d_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.remap_2d_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
remap those columns of 2D array that are present in map_old_to_new</p>
<p>Input:
arr ([batch_size, num_rules])
map_old_to_new</p>
<p>Output:
modified array</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.remap_1d_array">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">remap_1d_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_old_to_new</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#remap_1d_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.remap_1d_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
remap those positions of 1D array that are present in map_old_to_new</p>
<p>Input:
arr ([batch_size, num_rules])
map_old_to_new</p>
<p>Output:
modified array</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.modify_d_or_U_using_rule_map">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">modify_d_or_U_using_rule_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_U_or_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_map_old_to_new</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#modify_d_or_U_using_rule_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.modify_d_or_U_using_rule_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Modify d or U using the rule map</p>
<p>Input:
raw_U_or_d - the raw data (labelled(d) or unlabelled(U))
rule_map_old_to_new - the rule map</p>
<p>Output:
the modified raw_U_or_d</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.shuffle_F_d_U_Data">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">shuffle_F_d_U_Data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#shuffle_F_d_U_Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.shuffle_F_d_U_Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
shuffle the input data along the 0th axis i.e. among the different instances</p>
<p>Input:
data</p>
<p>Output:
the structured and shuffled F_d_U_Data</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.oversample_f_d">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">oversample_f_d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#oversample_f_d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.oversample_f_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Oversample the labelled data using the arguments provided</p>
<p>Input:
x ([batch_size, num_features]) - the data
labels
samping_dist</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_data_feeder_utils.oversample_d">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_data_feeder_utils.</span></code><code class="sig-name descname"><span class="pre">oversample_d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_dist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_data_feeder_utils.html#oversample_d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_data_feeder_utils.oversample_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
performs oversampling on the raw labelled data using the given distribution</p>
<p>Input:
raw_d - raw labelled data
sampling_dist - the given sampling dist</p>
<p>Output:
F_d_U_Data</p>
</dd></dl>

</section>
<section id="module-spear.Implyloss.my_gen_cross_entropy_utils">
<span id="implyloss-gen-cross-entropy-utils"></span><h2>Implyloss Gen Cross Entropy Utils<a class="headerlink" href="#module-spear.Implyloss.my_gen_cross_entropy_utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="spear.Implyloss.my_gen_cross_entropy_utils.generalized_cross_entropy">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_gen_cross_entropy_utils.</span></code><code class="sig-name descname"><span class="pre">generalized_cross_entropy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_hot_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_gen_cross_entropy_utils.html#generalized_cross_entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_gen_cross_entropy_utils.generalized_cross_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Computes the generalized cross entropy loss</p>
<p>Input:
logits([batch_size, num_classes]) - weights
one_hot_labels([batch_size, num_classes])
q (default = 0.6)</p>
<p>Output:
loss</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_gen_cross_entropy_utils.generalized_cross_entropy_bernoulli">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_gen_cross_entropy_utils.</span></code><code class="sig-name descname"><span class="pre">generalized_cross_entropy_bernoulli</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_gen_cross_entropy_utils.html#generalized_cross_entropy_bernoulli"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_gen_cross_entropy_utils.generalized_cross_entropy_bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
computes the bernoulli generalized cross entropy</p>
<p>Input:
p - base
q (default = 0.2) - exponent</p>
<p>Output:
loss</p>
</dd></dl>

</section>
<section id="module-spear.Implyloss.my_model">
<span id="implyloss-model"></span><h2>Implyloss Model<a class="headerlink" href="#module-spear.Implyloss.my_model" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-spear.Implyloss.my_pr_utils">
<span id="implyloss-pr-utils"></span><h2>Implyloss PR Utils<a class="headerlink" href="#module-spear.Implyloss.my_pr_utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.exp_term_for_constraints">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">exp_term_for_constraints</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#exp_term_for_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.exp_term_for_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the exponential term for the constraints</p>
<p>Input:
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C</p>
<p>Output:
the required exponential term</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.pr_product_term">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">pr_product_term</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#pr_product_term"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.pr_product_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the probability product term for the constraints</p>
<p>Input:
weights ([batch_size, num_rules]) - the w_network weights
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C</p>
<p>Output:
the required product term</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.get_q_y_from_p">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">get_q_y_from_p</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#get_q_y_from_p"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.get_q_y_from_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the q_y term from the p (f_network) distribution</p>
<p>Input:
f_probs ([batch_size, num_classes])
weights ([batch_size, num_rules]) - the w_network weights
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C</p>
<p>Output:
the required q_y term</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.get_q_r_from_p">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">get_q_r_from_p</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#get_q_r_from_p"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.get_q_r_from_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the q_r term from the p (f_network) distribution</p>
<p>Input:
f_probs ([batch_size, num_classes])
weights ([batch_size, num_rules]) - the w_network weights
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C</p>
<p>Output:
the required q_r term</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.theta_term_in_pr_loss">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">theta_term_in_pr_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_logits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#theta_term_in_pr_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.theta_term_in_pr_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the theta term in the pr loss</p>
<p>Input:
f_logits ([batch_size, num_classes])
f_probs ([batch_size, num_classes])
weights ([batch_size, num_rules]) - the w_network weights
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C
d ([batch_size,1])</p>
<p>Output:
the required theta term (third term in equation 14) -  used to supervise f (classification) network from instances in U</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.phi_term_in_pr_loss">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">phi_term_in_pr_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_logits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#phi_term_in_pr_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.phi_term_in_pr_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the phi term in the pr loss</p>
<p>Input:
m ([batch_size, num_rules]) - mij = 1 if ith example is associated with jth rule
w_logits ([batch_size, num_rules])
f_probs ([batch_size, num_classes])
weights ([batch_size, num_rules]) - the w_network weights
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C
d ([batch_size,1])</p>
<p>Output:
the required phi term (fourth term in equation 14) - used to superwise w (rule) network from instances in U</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_pr_utils.pr_loss">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_pr_utils.</span></code><code class="sig-name descname"><span class="pre">pr_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_logits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_logits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_pr_utils.html#pr_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_pr_utils.pr_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Compute the  pr loss</p>
<p>Input:
m ([batch_size, num_rules]) - mij = 1 if ith example is associated with jth rule
f_logits
w_logits ([batch_size, num_rules]) - logit before sigmoid activation in w network
f_probs ([batch_size, num_classes]) - output of f network
weights ([batch_size, num_rules]) - the sigmoid output from w network
rule_classes ([num_rules,1]) - a list of classes associated with the rules
num_classes (int)
C - lamda in equation 10 (hyperparameter)
d ([batch_size,1]) - if ith instance is from “d” set (labelled data) d[i] = 1, else if ith instance is from “U” set, d[i] = 0</p>
<p>Output:
the required phi term</p>
</dd></dl>

</section>
<section id="module-spear.Implyloss.my_test">
<span id="implyloss-test"></span><h2>Implyloss Test<a class="headerlink" href="#module-spear.Implyloss.my_test" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.Implyloss.my_test.HLSTest">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_test.</span></code><code class="sig-name descname"><span class="pre">HLSTest</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_test.html#HLSTest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_test.HLSTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Class Desc:
This Class is designed to test the HLS model and its accuracy and precision obtained on the validation and test datasets</p>
<dl class="py method">
<dt id="spear.Implyloss.my_test.HLSTest.maybe_save_predictions">
<code class="sig-name descname"><span class="pre">maybe_save_predictions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_test.html#HLSTest.maybe_save_predictions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_test.HLSTest.maybe_save_predictions" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Saves the predictions obtained from the model if required</p>
<p>Input:
self
save_filename - the filename where the predictions have to be saved if required
x ([batch_size, num_features])
l ([batch_size, num_rules])
m ([batch_size, num_rules])
preds
d ([batch_size,1]) - d[i] = 1 if the ith data instance is from the labelled dataset</p>
<p>Output:</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_test.HLSTest.test_f">
<code class="sig-name descname"><span class="pre">test_f</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datafeeder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test_f'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_joint_f_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_test.html#HLSTest.test_f"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_test.HLSTest.test_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
tests the f_network (classification network)</p>
<p>Input:
self
datafeeder - the datafeeder object
log_output (default - False)
data_type (fixed to test_f) - the type of the data that we want to test
save_filename (default - None) - the file where we can possibly store the test results
use_join_f_w (default - None)</p>
<p>Output:
precision
recall
f1_score
support</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_test.HLSTest.test_w">
<code class="sig-name descname"><span class="pre">test_w</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datafeeder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">my_data_types.test_w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_test.html#HLSTest.test_w"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_test.HLSTest.test_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
tests the w_network (rule network)</p>
<p>Input:
self
datafeeder - the datafeeder object
log_output (default - False)
data_type (fixed to test_w) - the type of the data that we want to test
save_filename (default - None) - the file where we can possibly store the test results</p>
<p>Analyzes:
the obtained w_predictions</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-spear.Implyloss.my_train">
<span id="implyloss-train"></span><h2>Implyloss Train<a class="headerlink" href="#module-spear.Implyloss.my_train" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="spear.Implyloss.my_train.HLSTrain">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_train.</span></code><code class="sig-name descname"><span class="pre">HLSTrain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
This Class is designed to train the HLS model using the Implyloss Algorithm</p>
<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.make_f_summary_ops">
<code class="sig-name descname"><span class="pre">make_f_summary_ops</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.make_f_summary_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.make_f_summary_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
make the summary of all the essential parameters of f_network</p>
<p>Input:
Self</p>
<p>Summarizes:
f_d_loss_ph
f_d_loss
f_d_f1_score_ph
f_d_f1_score
f_d_accuracy_ph
f_d_accuracy
f_d_avg_f1_score_ph
f_d_avg_f1_score
f_d_summaries</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.report_f_d_perfs_to_tensorboard">
<code class="sig-name descname"><span class="pre">report_f_d_perfs_to_tensorboard</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_d_loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.report_f_d_perfs_to_tensorboard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.report_f_d_perfs_to_tensorboard" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
report the f_d_performance to tensorboard</p>
<p>Input:
self
f_d_loss
metrics_dict
global_step</p>
<p>Output:</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.train_f_on_d">
<code class="sig-name descname"><span class="pre">train_f_on_d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datafeeder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_epochs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.train_f_on_d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.train_f_on_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
trains the f_network (classification network) on labelled data</p>
<p>Input:
self
datafeeder - datafeeder object
num_epochs - number of epochs for training</p>
<p>Output:</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.train_f_on_d_U">
<code class="sig-name descname"><span class="pre">train_f_on_d_U</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datafeeder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_epochs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_type</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.train_f_on_d_U"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.train_f_on_d_U" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
trains the f_network (classification network) on labelled amd unlabelled data</p>
<p>Input:
self
datafeeder - datafeeder object
num_epochs - number of epochs for training
loss_type - different available losses</p>
<p>Output:</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.init_metrics">
<code class="sig-name descname"><span class="pre">init_metrics</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.init_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.init_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Func desc:
initialize the metrics</p>
<p>Input:
self</p>
<p>Output:</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.get_metric">
<code class="sig-name descname"><span class="pre">get_metric</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.get_metric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.get_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Func desc:
get the metrics</p>
<p>Input:
self
run_type
metrics_dict</p>
<p>Output:
the required metrics_dict</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.save_metrics">
<code class="sig-name descname"><span class="pre">save_metrics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.save_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.save_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Func desc:
save the metrics</p>
<p>Input:
self
run_type
metrics_dict</p>
<p>Prints:
The saved metric file</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.maybe_save_metrics_dict">
<code class="sig-name descname"><span class="pre">maybe_save_metrics_dict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.maybe_save_metrics_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.maybe_save_metrics_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Func desc:
save the metric if it is the best till now</p>
<p>Input:
self
run_type
metrics_dict</p>
<p>Output:
True or False denoting whether the current metric is saved or not</p>
<p>Prints:
The saved metric file</p>
</dd></dl>

<dl class="py method">
<dt id="spear.Implyloss.my_train.HLSTrain.compute_f_d_metrics">
<code class="sig-name descname"><span class="pre">compute_f_d_metrics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metrics_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recall</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f1_score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_epoch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_d_global_step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_train.html#HLSTrain.compute_f_d_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_train.HLSTrain.compute_f_d_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Func desc:
compute the f_d metrics</p>
<p>input:
self
metrics_dict
precision
recall
f1_score
support
global_epoch
f_d_global_step</p>
<p>output:
void</p>
<p>evaluates:
metrics_dict, accuracy</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-spear.Implyloss.my_utils">
<span id="implyloss-utils"></span><h2>Implyloss Utils<a class="headerlink" href="#module-spear.Implyloss.my_utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="spear.Implyloss.my_utils.get_data">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">get_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#get_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
takes the pickle file and arranges it in a matrix list form so as to set the member variables accordingly
expected order in pickle file is NUMPY arrays x, l, m, L, d, r, s, n, k
x: [num_instances, num_features]
l: [num_instances, num_rules]
m: [num_instances, num_rules]
L: [num_instances, 1]
d: [num_instances, 1]
r: [num_instances, num_rules]
s: [num_instances, num_rules]
n: [num_rules] Mask for s
k: [num_rules] LF classes, range 0 to num_classes-1</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.analyze_w_predictions">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">analyze_w_predictions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#analyze_w_predictions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.analyze_w_predictions" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
analyze the rule network by computing the precisions of the rules and comparing old and new rule stats</p>
<p>input:
x: [num_instances, num_features]
l: [num_instances, num_rules]
m: [num_instances, num_rules]
L: [num_instances, 1]
d: [num_instances, 1]
weights: [num_instances, num_rules]
probs: [num_instances, num_classes]
rule_classes: [num_rules,1]</p>
<p>output:
void, prints the required statistics</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.convert_weights_to_m">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">convert_weights_to_m</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#convert_weights_to_m"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.convert_weights_to_m" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
converts weights to m</p>
<p>input:
weights([batch_size, num_rules]) - the weights matrix corresponding to rule network(w_network) in the algorithm</p>
<p>output:
m([batch_size, num_rules]) - the rule coverage matrix where m_ij = 1 if jth rule covers ith instance</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.convert_m_to_l">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">convert_m_to_l</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#convert_m_to_l"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.convert_m_to_l" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
converts m to l</p>
<p>input:
m([batch_size, num_rules]) - the rule coverage matrix where m_ij = 1 if jth rule covers ith instance
rule_classes -
num_classes(non_negative integer) - number of available classes</p>
<p>output:
l([batch_size, num_rules]) - labels assigned by the rules</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.get_rule_precision">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">get_rule_precision</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#get_rule_precision"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.get_rule_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
get the precision of the rules</p>
<p>input:
l([batch_size, num_rules]) - labels assigned by the rules
L([batch_size, 1]) - L_i = 1 if the ith instance has already a label assigned to it in the dataset
m([batch_size, num_rules]) - the rule coverage matrix where m_ij = 1 if jth rule covers ith instance</p>
<p>output:
micro_p -
macro_p -
comp -</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.merge_dict_a_into_b">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">merge_dict_a_into_b</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#merge_dict_a_into_b"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.merge_dict_a_into_b" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
set the dict values of b to that of a</p>
<p>input:
a, b : dicts</p>
<p>output:
void</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.print_tf_global_variables">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">print_tf_global_variables</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#print_tf_global_variables"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.print_tf_global_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
prints all the global variables</p>
<p>Input:</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.print_var_list">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">print_var_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#print_var_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.print_var_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Prints the given variable list</p>
<p>Input:
var_list</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.pretty_print">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">pretty_print</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_structure</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#pretty_print"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.pretty_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
prints the given data structure in the desired format</p>
<p>Input:
data_structure</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.get_list_or_None">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">get_list_or_None</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'int'&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#get_list_or_None"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.get_list_or_None" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
Returns the list of types of the variables in the string s</p>
<p>Input:
s - string
dtype function (default - int)</p>
<p>Output:
None or list</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.get_list">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">get_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#get_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.get_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
returns the output of get_list_or_None as a list</p>
<p>Input:
s - list</p>
<p>Output:
lst - list</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.None_if_zero">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">None_if_zero</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#None_if_zero"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.None_if_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
the max(0,n) function with none id n&lt;=0</p>
<p>Input:
n - integer</p>
<p>Output:
if n&gt;0 then n else None</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.boolean">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">boolean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#boolean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
returns the expected boolean value for the given string</p>
<p>Input:
s - string</p>
<p>Output:
boolean or error</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.set_to_list_of_values_if_None_or_empty">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">set_to_list_of_values_if_None_or_empty</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_vals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#set_to_list_of_values_if_None_or_empty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.set_to_list_of_values_if_None_or_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
returns lst if it is not empty else returns a same length list but with all its entries equal to val
lst - list
val - value
num_vals (integer) - length of the list lst</p>
<p>Output:
lst or same length val list</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.conv_l_to_lsnork">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">conv_l_to_lsnork</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#conv_l_to_lsnork"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.conv_l_to_lsnork" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
in snorkel convention
if a rule does not cover an instance assign it label -1
we follow the convention where we assign the label num_classes instead of -1
valid class labels range from {0,1,…num_classes-1}
conv_l_to_lsnork:  converts l in our format to snorkel’s format</p>
<p>input:
l([batch_size, num_rules]) - rule label matrix
m([batch_size, num_rules]) - rule coverage matrix</p>
<p>output:
lsnork([batch_size, num_rules])</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.compute_accuracy">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">compute_accuracy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">support</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recall</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#compute_accuracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.compute_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>func desc:
compute the required accuracy</p>
<p>input:
support
recall</p>
<p>output:
accuracy</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.dump_labels_to_file">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">dump_labels_to_file</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_d_U_probs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rule_classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#dump_labels_to_file"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.dump_labels_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
dumps the given data into a pickle file</p>
<p>Input:
save_filename - the name of the pickle file in which the arguments/data is required to be saved
x ([batch_size x num_features])
l ([batch_size x num_rules])
m ([batch_size x num_rules])
L ([batch_size x 1])
d ([batch_size x 1])
weights (default - None)
f_d_U_probs (default - None)
rule_classes  (default - None)</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.load_from_pickle_with_per_class_sampling_factor">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">load_from_pickle_with_per_class_sampling_factor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">per_class_sampling_factor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#load_from_pickle_with_per_class_sampling_factor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.load_from_pickle_with_per_class_sampling_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
load the data from the given pickle file with per class sampling factor</p>
<p>Input:
fname - name of the pickle file from which data need to be loaded
per_class_sampling_factor</p>
<p>Output:
the required matrices
x1 ([batch_size x num_features])
l1 ([batch_size x num_rules])
m1 ([batch_size x num_rules])
L1 ([batch_size x 1])
d1 ([batch_size x 1])</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.combine_d_covered_U_pickles">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">combine_d_covered_U_pickles</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_U_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_sampling_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_sampling_factor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#combine_d_covered_U_pickles"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.combine_d_covered_U_pickles" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
combine the labelled and unlabelled data, merge the corresponding parameters together and store them in new file</p>
<p>Input:
d_name - the pickle file storing labelled data
infer_U_name - the pickle file storing unlabelled data
out_name - the name of the file where merged output needs to be stored
d_sampling_factor - the per_class_sampling_factor for labelled data
U_sampling_factor - the per_class_sampling_factor for unlabelled data</p>
<p>Output:</p>
</dd></dl>

<dl class="py function">
<dt id="spear.Implyloss.my_utils.updated_theta_copy">
<code class="sig-prename descclassname"><span class="pre">spear.Implyloss.my_utils.</span></code><code class="sig-name descname"><span class="pre">updated_theta_copy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grads</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spear/Implyloss/my_utils.html#updated_theta_copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spear.Implyloss.my_utils.updated_theta_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Func Desc:
updates the theta (parameters) using rhe given learning rate, grads and variables</p>
<p>Input:
grads - gradients
variables
lr - learning rate
mode</p>
<p>Output:
vals - list of the updated gradients</p>
</dd></dl>

</section>
</section>
<section id="bibilography">
<h1>Bibilography<a class="headerlink" href="#bibilography" title="Permalink to this headline">¶</a></h1>
<p id="id14"><dl class="citation">
<dt class="label" id="id15"><span class="brackets">CRS20</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id5">2</a>,<a href="#id6">3</a>,<a href="#id7">4</a>,<a href="#id8">5</a>,<a href="#id9">6</a>,<a href="#id10">7</a>)</span></dt>
<dd><p>Oishik Chatterjee, Ganesh Ramakrishnan, and Sunita Sarawagi. <em>Robust Data Programming with Precision-guided Labeling Functions</em>. Proceedings of the AAAI Conference on Artificial Intelligence, 2020.</p>
</dd>
<dt class="label" id="id16"><span class="brackets">MCK+20</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>,<a href="#id4">3</a>,<a href="#id11">4</a>,<a href="#id12">5</a>,<a href="#id13">6</a>)</span></dt>
<dd><p>Ayush Maheshwari, Oishik Chatterjee, KrishnaTeja Killamsetty, Rishabh Iyer, and Ganesh Ramakrishnan. <em>Data Programming using Semi-Supervision and Subset Selection</em>. 2020.</p>
</dd>
</dl>
</p>
</section>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Ganesh_Sir, Ayush_Maheshwari, Guttu_Sai_Abhishek, Harshad_Ingole, Parth_Laturia, Vineeth_Dorna.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>